import React, { useState, useRef } from 'react';
import { View, Text, TextInput, Button, TouchableOpacity, ActivityIndicator, ProgressBar, StyleSheet } from 'react-native';
import MaterialCommunityIcons from 'react-native-vector-icons/MaterialCommunityIcons';

const REBOOT = 1;
const READY_TO_RECEIVE = 2;
const ERROR_NO_FREE = 3;
const CHUNK_LENGTH = 240;
const SECTOR_SIZE = 8 * 1024;

const Ota = (props) => {
  const [selectedAction, setSelectedAction] = useState(null);
  const [isUploadButtonDisabled, setIsUploadButtonDisabled] = useState(true);
  const [progress, setProgress] = useState(0);
  const [startSector, setStartSector] = useState('');
  const [nbSector, setNbSector] = useState('');
  const [manuallySettingNbSector, setManuallySettingNbSector] = useState(false);

  const characteristics = props.route.params.device.characteristics || [];

  let writeAddressCharacteristic;
  let indicateCharacteristic;
  let writeWithoutResponseCharacteristic;
  let fileContent;
  let fileLength;
  let nbSectorHex;
  let uploadAction;
  let readyToReceive = false;

  characteristics.forEach((element) => {
    switch (element.characteristic.uuid) {
      case "0000fe22-8e22-4541-9d4c-21edae82ed19":
        writeAddressCharacteristic = element;
        break;
      case "0000fe23-8e22-4541-9d4c-21edae82ed19":
        indicateCharacteristic = element;
        break;
      case "0000fe24-8e22-4541-9d4c-21edae82ed19":
        writeWithoutResponseCharacteristic = element;
        break;
      default:
        console.log("No relevant characteristics found.");
    }
  });

  if (indicateCharacteristic) {
    console.log('Indications ON');
    indicateCharacteristic.characteristic.startNotifications();
    indicateCharacteristic.characteristic.oncharacteristicvaluechanged = notifHandler;
  }

  function notifHandler(event) {
    console.log("Notification / Indication received");
    var buf = new Uint8Array(event.target.value.buffer);
    console.log(buf);
    if (buf[0] === REBOOT) {
      setIsUploadButtonDisabled(true);
    } else if (buf[0] === READY_TO_RECEIVE) {
      readyToReceive = true;
      sliceAndSend();
    } else if (buf[0] === ERROR_NO_FREE) {
      console.log("Error: no free space.");
    }
  }

  async function writeAddress() {
    const address = startSector;
    const hexStringFirstPart = parseInt(address.substring(0, 2), 16);
    const hexStringSecondPart = parseInt(address.substring(2, 4), 16);
    const hexStringThirdPart = parseInt(address.substring(4, 6), 16);
    nbSectorHex = parseInt(nbSector).toString(16);

    let myWord = new Uint8Array(5);
    myWord[0] = uploadAction;
    myWord[1] = hexStringFirstPart;
    myWord[2] = hexStringSecondPart;
    myWord[3] = hexStringThirdPart;
    myWord[4] = parseInt(nbSectorHex, 16);

    try {
      await writeAddressCharacteristic.characteristic.writeValue(myWord);
      console.log("Writing >> " + myWord);
    } catch (error) {
      console.log("Error writing address: " + error);
    }
  }

  function indicationTimeout() {
    setIsUploadButtonDisabled(true);
  }

  async function onUploadButtonClick() {
    if (!manuallySettingNbSector) {
      calculateNbSector();
    } else {
      fileLength = fileContent.length;
      console.log("Manually set the number of sectors =", nbSector);
    }

    setIsUploadButtonDisabled(true);
    writeAddress();
    sliceAndSend();
  }

  async function sliceAndSend() {
    let start = 0;
    let end = CHUNK_LENGTH;
    let totalBytes = 0;

    if (readyToReceive) {
      const startTime = performance.now();
      while (start < fileLength) {
        const sub = fileContent.slice(start, end);
        start = end;
        end += CHUNK_LENGTH;
        await writeWithoutResponseCharacteristic.characteristic.writeValue(sub);
        totalBytes += sub.byteLength;
        setProgress((totalBytes * 100) / fileLength);
        console.log(`Writing ${totalBytes} bytes...`);
      }

      const FileUploadFinished = new Uint8Array([7]);
      await writeAddressCharacteristic.characteristic.writeValue(FileUploadFinished);

      const endTime = performance.now();
      console.log(`Firmware update took: ${endTime - startTime} ms`);

      setIsUploadButtonDisabled(true);
      setTimeout(indicationTimeout, 30000);
    } else {
      console.log("Not ready to receive...");
    }
  }

  async function showFile() {
    try {
      const res = await DocumentPicker.pick({
        type: [DocumentPicker.types.allFiles],
      });
      console.log(res);
      const reader = new FileReader();
      reader.onload = () => {
        const uint8View = new Uint8Array(reader.result);
        fileContent = uint8View;
        setIsUploadButtonDisabled(false);
      };
      reader.readAsArrayBuffer(res.uri);
    } catch (err) {
      if (DocumentPicker.isCancel(err)) {
        console.log('Canceled');
      } else {
        throw err;
      }
    }
  }
  
  function calculateNbSector() {
    fileLength = fileContent.length;
    const sectors = Math.ceil(fileLength / SECTOR_SIZE);
    setNbSector(sectors);
    console.log("file length =", fileLength);
    console.log("NbSector =", sectors);
  }

  function onActionRadioButtonClick(value) {
    setSelectedAction(value);
    switch (value) {
      case 'userData':
        uploadAction = 1;
        setStartSector("0F6000");
        break;
      case 'application':
        uploadAction = 2;
        setStartSector("07C000");
        break;
    }
  }

  function checkBoxClickForNbSector() {
    setManuallySettingNbSector(!manuallySettingNbSector);
  }

  return (
    <View style={styles.container}>
      <TouchableOpacity style={styles.option} onPress={() => onActionRadioButtonClick('userData')}>
        <Text>
          <MaterialCommunityIcons name="file-cog-outline" size={20} /> User Configuration Data Update
        </Text>
      </TouchableOpacity>
      <TouchableOpacity style={styles.option} onPress={() => onActionRadioButtonClick('application')}>
        <Text>
          <MaterialCommunityIcons name="file-upload-outline" size={20} /> Application Update
        </Text>
      </TouchableOpacity>

      {selectedAction && (
        <View style={styles.actionContainer}>
          <Text>
            <MaterialCommunityIcons name="folder-open-outline" size={20} /> Select File
          </Text>
          <Button title="Choose File" onPress={() => { /* Implement file picker */ }} />

          <TextInput
            style={styles.input}
            value={startSector}
            onChangeText={setStartSector}
            placeholder="Enter Start Sector"
          />

          <TouchableOpacity style={styles.checkbox} onPress={checkBoxClickForNbSector}>
            <Text>
              <MaterialCommunityIcons name={manuallySettingNbSector ? "checkbox-marked-outline" : "checkbox-blank-outline"} size={20} /> Set number of sectors manually
            </Text>
          </TouchableOpacity>

          <TextInput
            style={[styles.input, { backgroundColor: manuallySettingNbSector ? 'white' : '#f0f0f0' }]}
            value={nbSector.toString()}
            onChangeText={setNbSector}
            editable={manuallySettingNbSector}
            placeholder="Number of Sectors"
          />

          <Button
            title="Upload"
            onPress={onUploadButtonClick}
            disabled={isUploadButtonDisabled}
            color="#6200EE"
          />

          <ProgressBar
            styleAttr="Horizontal"
            indeterminate={false}
            progress={progress / 100}
            style={styles.progressBar}
          />

          {isUploadButtonDisabled && (
            <ActivityIndicator size="large" color="#6200EE" style={styles.activityIndicator} />
          )}
        </View>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    padding: 20,
    flex: 1,
    backgroundColor: '#fff',
  },
  option: {
    marginVertical: 10,
  },
  actionContainer: {
    marginTop: 20,
  },
  input: {
    height: 40,
    borderColor: '#ccc',
    borderWidth: 1,
    marginVertical: 10,
    paddingHorizontal: 10,
    borderRadius: 5,
  },
  checkbox: {
    marginVertical: 10,
    flexDirection: 'row',
    alignItems: 'center',
  },
  progressBar: {
    marginTop: 20,
    height: 10,
    borderRadius: 5,
  },
  activityIndicator: {
    marginTop: 20,
  },
});

export default Ota;

